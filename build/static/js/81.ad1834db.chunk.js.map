{"version":3,"file":"static/js/81.ad1834db.chunk.js","mappings":"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","sources":["../node_modules/@capacitor/filesystem/src/web.ts"],"sourcesContent":["import { WebPlugin, buildRequestInit } from '@capacitor/core';\n\nimport type {\n  AppendFileOptions,\n  CopyOptions,\n  CopyResult,\n  DeleteFileOptions,\n  FilesystemPlugin,\n  GetUriOptions,\n  GetUriResult,\n  MkdirOptions,\n  PermissionStatus,\n  ReadFileOptions,\n  ReadFileResult,\n  ReaddirOptions,\n  ReaddirResult,\n  RenameOptions,\n  RmdirOptions,\n  StatOptions,\n  StatResult,\n  WriteFileOptions,\n  WriteFileResult,\n  Directory,\n  DownloadFileOptions,\n  DownloadFileResult,\n  ProgressStatus,\n} from './definitions';\nimport { Encoding } from './definitions';\n\nfunction resolve(path: string): string {\n  const posix = path.split('/').filter(item => item !== '.');\n  const newPosix: string[] = [];\n\n  posix.forEach(item => {\n    if (\n      item === '..' &&\n      newPosix.length > 0 &&\n      newPosix[newPosix.length - 1] !== '..'\n    ) {\n      newPosix.pop();\n    } else {\n      newPosix.push(item);\n    }\n  });\n\n  return newPosix.join('/');\n}\nfunction isPathParent(parent: string, children: string): boolean {\n  parent = resolve(parent);\n  children = resolve(children);\n  const pathsA = parent.split('/');\n  const pathsB = children.split('/');\n\n  return (\n    parent !== children &&\n    pathsA.every((value, index) => value === pathsB[index])\n  );\n}\n\nexport class FilesystemWeb extends WebPlugin implements FilesystemPlugin {\n  DB_VERSION = 1;\n  DB_NAME = 'Disc';\n\n  private _writeCmds: string[] = ['add', 'put', 'delete'];\n  private _db?: IDBDatabase;\n  static _debug = true;\n  async initDb(): Promise<IDBDatabase> {\n    if (this._db !== undefined) {\n      return this._db;\n    }\n    if (!('indexedDB' in window)) {\n      throw this.unavailable(\"This browser doesn't support IndexedDB\");\n    }\n\n    return new Promise<IDBDatabase>((resolve, reject) => {\n      const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);\n      request.onupgradeneeded = FilesystemWeb.doUpgrade;\n      request.onsuccess = () => {\n        this._db = request.result;\n        resolve(request.result);\n      };\n      request.onerror = () => reject(request.error);\n      request.onblocked = () => {\n        console.warn('db blocked');\n      };\n    });\n  }\n\n  static doUpgrade(event: IDBVersionChangeEvent): void {\n    const eventTarget = event.target as IDBOpenDBRequest;\n    const db = eventTarget.result;\n    switch (event.oldVersion) {\n      case 0:\n      case 1:\n      default: {\n        if (db.objectStoreNames.contains('FileStorage')) {\n          db.deleteObjectStore('FileStorage');\n        }\n        const store = db.createObjectStore('FileStorage', { keyPath: 'path' });\n        store.createIndex('by_folder', 'folder');\n      }\n    }\n  }\n\n  async dbRequest(cmd: string, args: any[]): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: any = tx.objectStore('FileStorage');\n        const req = store[cmd](...args);\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  async dbIndexRequest(\n    indexName: string,\n    cmd: string,\n    args: [any],\n  ): Promise<any> {\n    const readFlag =\n      this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';\n    return this.initDb().then((conn: IDBDatabase) => {\n      return new Promise<IDBObjectStore>((resolve, reject) => {\n        const tx: IDBTransaction = conn.transaction(['FileStorage'], readFlag);\n        const store: IDBObjectStore = tx.objectStore('FileStorage');\n        const index: any = store.index(indexName);\n        const req = index[cmd](...args) as any;\n        req.onsuccess = () => resolve(req.result);\n        req.onerror = () => reject(req.error);\n      });\n    });\n  }\n\n  private getPath(\n    directory: Directory | undefined,\n    uriPath: string | undefined,\n  ): string {\n    const cleanedUriPath =\n      uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';\n    let fsPath = '';\n    if (directory !== undefined) fsPath += '/' + directory;\n    if (uriPath !== '') fsPath += '/' + cleanedUriPath;\n    return fsPath;\n  }\n\n  async clear(): Promise<void> {\n    const conn: IDBDatabase = await this.initDb();\n    const tx: IDBTransaction = conn.transaction(['FileStorage'], 'readwrite');\n    const store: IDBObjectStore = tx.objectStore('FileStorage');\n    store.clear();\n  }\n\n  /**\n   * Read a file from disk\n   * @param options options for the file read\n   * @return a promise that resolves with the read file data result\n   */\n  async readFile(options: ReadFileOptions): Promise<ReadFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    // const encoding = options.encoding;\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    return { data: entry.content ? entry.content : '' };\n  }\n\n  /**\n   * Write a file to disk in the specified location on device\n   * @param options options for the file write\n   * @return a promise that resolves with the file write result\n   */\n  async writeFile(options: WriteFileOptions): Promise<WriteFileResult> {\n    const path: string = this.getPath(options.directory, options.path);\n    let data = options.data;\n    const encoding = options.encoding;\n    const doRecursive = options.recursive;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: doRecursive,\n        });\n      }\n    }\n\n    if (!encoding && !(data instanceof Blob)) {\n      data = data.indexOf(',') >= 0 ? data.split(',')[1] : data;\n      if (!this.isBase64String(data))\n        throw Error('The supplied data is not valid base64 content.');\n    }\n\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data instanceof Blob ? data.size : data.length,\n      ctime: now,\n      mtime: now,\n      content: data,\n    };\n    await this.dbRequest('put', [pathObj]);\n    return {\n      uri: pathObj.path,\n    };\n  }\n\n  /**\n   * Append to a file on disk in the specified location on device\n   * @param options options for the file append\n   * @return a promise that resolves with the file write result\n   */\n  async appendFile(options: AppendFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    let data = options.data;\n    const encoding = options.encoding;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const now = Date.now();\n    let ctime = now;\n\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (occupiedEntry && occupiedEntry.type === 'directory')\n      throw Error('The supplied path is a directory.');\n\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    if (parentEntry === undefined) {\n      const subDirIndex = parentPath.indexOf('/', 1);\n      if (subDirIndex !== -1) {\n        const parentArgPath = parentPath.substr(subDirIndex);\n        await this.mkdir({\n          path: parentArgPath,\n          directory: options.directory,\n          recursive: true,\n        });\n      }\n    }\n\n    if (!encoding && !this.isBase64String(data))\n      throw Error('The supplied data is not valid base64 content.');\n\n    if (occupiedEntry !== undefined) {\n      if (occupiedEntry.content instanceof Blob) {\n        throw Error(\n          'The occupied entry contains a Blob object which cannot be appended to.',\n        );\n      }\n\n      if (occupiedEntry.content !== undefined && !encoding) {\n        data = btoa(atob(occupiedEntry.content) + atob(data));\n      } else {\n        data = occupiedEntry.content + data;\n      }\n      ctime = occupiedEntry.ctime;\n    }\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'file',\n      size: data.length,\n      ctime: ctime,\n      mtime: now,\n      content: data,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Delete a file from disk\n   * @param options options for the file delete\n   * @return a promise that resolves with the deleted file data result\n   */\n  async deleteFile(options: DeleteFileOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) throw Error('File does not exist.');\n    const entries = await this.dbIndexRequest('by_folder', 'getAllKeys', [\n      IDBKeyRange.only(path),\n    ]);\n    if (entries.length !== 0) throw Error('Folder is not empty.');\n\n    await this.dbRequest('delete', [path]);\n  }\n\n  /**\n   * Create a directory.\n   * @param options options for the mkdir\n   * @return a promise that resolves with the mkdir result\n   */\n  async mkdir(options: MkdirOptions): Promise<void> {\n    const path: string = this.getPath(options.directory, options.path);\n    const doRecursive = options.recursive;\n    const parentPath = path.substr(0, path.lastIndexOf('/'));\n\n    const depth = (path.match(/\\//g) || []).length;\n    const parentEntry = (await this.dbRequest('get', [parentPath])) as EntryObj;\n    const occupiedEntry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (depth === 1) throw Error('Cannot create Root directory');\n    if (occupiedEntry !== undefined)\n      throw Error('Current directory does already exist.');\n    if (!doRecursive && depth !== 2 && parentEntry === undefined)\n      throw Error('Parent directory must exist');\n\n    if (doRecursive && depth !== 2 && parentEntry === undefined) {\n      const parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));\n      await this.mkdir({\n        path: parentArgPath,\n        directory: options.directory,\n        recursive: doRecursive,\n      });\n    }\n    const now = Date.now();\n    const pathObj: EntryObj = {\n      path: path,\n      folder: parentPath,\n      type: 'directory',\n      size: 0,\n      ctime: now,\n      mtime: now,\n    };\n    await this.dbRequest('put', [pathObj]);\n  }\n\n  /**\n   * Remove a directory\n   * @param options the options for the directory remove\n   */\n  async rmdir(options: RmdirOptions): Promise<void> {\n    const { path, directory, recursive } = options;\n    const fullPath: string = this.getPath(directory, path);\n\n    const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n\n    if (entry === undefined) throw Error('Folder does not exist.');\n\n    if (entry.type !== 'directory')\n      throw Error('Requested path is not a directory');\n\n    const readDirResult = await this.readdir({ path, directory });\n\n    if (readDirResult.files.length !== 0 && !recursive)\n      throw Error('Folder is not empty');\n\n    for (const entry of readDirResult.files) {\n      const entryPath = `${path}/${entry.name}`;\n      const entryObj = await this.stat({ path: entryPath, directory });\n      if (entryObj.type === 'file') {\n        await this.deleteFile({ path: entryPath, directory });\n      } else {\n        await this.rmdir({ path: entryPath, directory, recursive });\n      }\n    }\n\n    await this.dbRequest('delete', [fullPath]);\n  }\n\n  /**\n   * Return a list of files from the directory (not recursive)\n   * @param options the options for the readdir operation\n   * @return a promise that resolves with the readdir directory listing result\n   */\n  async readdir(options: ReaddirOptions): Promise<ReaddirResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    const entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (options.path !== '' && entry === undefined)\n      throw Error('Folder does not exist.');\n\n    const entries: string[] = await this.dbIndexRequest(\n      'by_folder',\n      'getAllKeys',\n      [IDBKeyRange.only(path)],\n    );\n    const files = await Promise.all(\n      entries.map(async e => {\n        let subEntry = (await this.dbRequest('get', [e])) as EntryObj;\n        if (subEntry === undefined) {\n          subEntry = (await this.dbRequest('get', [e + '/'])) as EntryObj;\n        }\n        return {\n          name: e.substring(path.length + 1),\n          type: subEntry.type,\n          size: subEntry.size,\n          ctime: subEntry.ctime,\n          mtime: subEntry.mtime,\n          uri: subEntry.path,\n        };\n      }),\n    );\n    return { files: files };\n  }\n\n  /**\n   * Return full File URI for a path and directory\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async getUri(options: GetUriOptions): Promise<GetUriResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    return {\n      uri: entry?.path || path,\n    };\n  }\n\n  /**\n   * Return data about a file\n   * @param options the options for the stat operation\n   * @return a promise that resolves with the file stat result\n   */\n  async stat(options: StatOptions): Promise<StatResult> {\n    const path: string = this.getPath(options.directory, options.path);\n\n    let entry = (await this.dbRequest('get', [path])) as EntryObj;\n    if (entry === undefined) {\n      entry = (await this.dbRequest('get', [path + '/'])) as EntryObj;\n    }\n    if (entry === undefined) throw Error('Entry does not exist.');\n\n    return {\n      type: entry.type,\n      size: entry.size,\n      ctime: entry.ctime,\n      mtime: entry.mtime,\n      uri: entry.path,\n    };\n  }\n\n  /**\n   * Rename a file or directory\n   * @param options the options for the rename operation\n   * @return a promise that resolves with the rename result\n   */\n  async rename(options: RenameOptions): Promise<void> {\n    await this._copy(options, true);\n    return;\n  }\n\n  /**\n   * Copy a file or directory\n   * @param options the options for the copy operation\n   * @return a promise that resolves with the copy result\n   */\n  async copy(options: CopyOptions): Promise<CopyResult> {\n    return this._copy(options, false);\n  }\n\n  async requestPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  async checkPermissions(): Promise<PermissionStatus> {\n    return { publicStorage: 'granted' };\n  }\n\n  /**\n   * Function that can perform a copy or a rename\n   * @param options the options for the rename operation\n   * @param doRename whether to perform a rename or copy operation\n   * @return a promise that resolves with the result\n   */\n  private async _copy(\n    options: CopyOptions,\n    doRename = false,\n  ): Promise<CopyResult> {\n    let { toDirectory } = options;\n    const { to, from, directory: fromDirectory } = options;\n\n    if (!to || !from) {\n      throw Error('Both to and from must be provided');\n    }\n\n    // If no \"to\" directory is provided, use the \"from\" directory\n    if (!toDirectory) {\n      toDirectory = fromDirectory;\n    }\n\n    const fromPath = this.getPath(fromDirectory, from);\n    const toPath = this.getPath(toDirectory, to);\n\n    // Test that the \"to\" and \"from\" locations are different\n    if (fromPath === toPath) {\n      return {\n        uri: toPath,\n      };\n    }\n\n    if (isPathParent(fromPath, toPath)) {\n      throw Error('To path cannot contain the from path');\n    }\n\n    // Check the state of the \"to\" location\n    let toObj;\n    try {\n      toObj = await this.stat({\n        path: to,\n        directory: toDirectory,\n      });\n    } catch (e) {\n      // To location does not exist, ensure the directory containing \"to\" location exists and is a directory\n      const toPathComponents = to.split('/');\n      toPathComponents.pop();\n      const toPath = toPathComponents.join('/');\n\n      // Check the containing directory of the \"to\" location exists\n      if (toPathComponents.length > 0) {\n        const toParentDirectory = await this.stat({\n          path: toPath,\n          directory: toDirectory,\n        });\n\n        if (toParentDirectory.type !== 'directory') {\n          throw new Error('Parent directory of the to path is a file');\n        }\n      }\n    }\n\n    // Cannot overwrite a directory\n    if (toObj && toObj.type === 'directory') {\n      throw new Error('Cannot overwrite a directory with a file');\n    }\n\n    // Ensure the \"from\" object exists\n    const fromObj = await this.stat({\n      path: from,\n      directory: fromDirectory,\n    });\n\n    // Set the mtime/ctime of the supplied path\n    const updateTime = async (path: string, ctime: number, mtime: number) => {\n      const fullPath: string = this.getPath(toDirectory, path);\n      const entry = (await this.dbRequest('get', [fullPath])) as EntryObj;\n      entry.ctime = ctime;\n      entry.mtime = mtime;\n      await this.dbRequest('put', [entry]);\n    };\n\n    const ctime = fromObj.ctime ? fromObj.ctime : Date.now();\n\n    switch (fromObj.type) {\n      // The \"from\" object is a file\n      case 'file': {\n        // Read the file\n        const file = await this.readFile({\n          path: from,\n          directory: fromDirectory,\n        });\n\n        // Optionally remove the file\n        if (doRename) {\n          await this.deleteFile({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n\n        let encoding;\n        if (!(file.data instanceof Blob) && !this.isBase64String(file.data)) {\n          encoding = Encoding.UTF8;\n        }\n\n        // Write the file to the new location\n        const writeResult = await this.writeFile({\n          path: to,\n          directory: toDirectory,\n          data: file.data,\n          encoding: encoding,\n        });\n\n        // Copy the mtime/ctime of a renamed file\n        if (doRename) {\n          await updateTime(to, ctime, fromObj.mtime);\n        }\n\n        // Resolve promise\n        return writeResult;\n      }\n      case 'directory': {\n        if (toObj) {\n          throw Error('Cannot move a directory over an existing object');\n        }\n\n        try {\n          // Create the to directory\n          await this.mkdir({\n            path: to,\n            directory: toDirectory,\n            recursive: false,\n          });\n\n          // Copy the mtime/ctime of a renamed directory\n          if (doRename) {\n            await updateTime(to, ctime, fromObj.mtime);\n          }\n        } catch (e) {\n          // ignore\n        }\n\n        // Iterate over the contents of the from location\n        const contents = (\n          await this.readdir({\n            path: from,\n            directory: fromDirectory,\n          })\n        ).files;\n\n        for (const filename of contents) {\n          // Move item from the from directory to the to directory\n          await this._copy(\n            {\n              from: `${from}/${filename.name}`,\n              to: `${to}/${filename.name}`,\n              directory: fromDirectory,\n              toDirectory,\n            },\n            doRename,\n          );\n        }\n\n        // Optionally remove the original from directory\n        if (doRename) {\n          await this.rmdir({\n            path: from,\n            directory: fromDirectory,\n          });\n        }\n      }\n    }\n    return {\n      uri: toPath,\n    };\n  }\n\n  /**\n   * Function that performs a http request to a server and downloads the file to the specified destination\n   *\n   * @param options the options for the download operation\n   * @returns a promise that resolves with the download file result\n   */\n  public downloadFile = async (\n    options: DownloadFileOptions,\n  ): Promise<DownloadFileResult> => {\n    const requestInit = buildRequestInit(options, options.webFetchExtra);\n    const response = await fetch(options.url, requestInit);\n    let blob: Blob;\n\n    if (!options.progress) blob = await response.blob();\n    else if (!response?.body) blob = new Blob();\n    else {\n      const reader = response.body.getReader();\n\n      let bytes = 0;\n      const chunks: (Uint8Array | undefined)[] = [];\n\n      const contentType: string | null = response.headers.get('content-type');\n      const contentLength: number = parseInt(\n        response.headers.get('content-length') || '0',\n        10,\n      );\n\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) break;\n\n        chunks.push(value);\n        bytes += value?.length || 0;\n\n        const status: ProgressStatus = {\n          url: options.url,\n          bytes,\n          contentLength,\n        };\n\n        this.notifyListeners('progress', status);\n      }\n\n      const allChunks = new Uint8Array(bytes);\n      let position = 0;\n      for (const chunk of chunks) {\n        if (typeof chunk === 'undefined') continue;\n\n        allChunks.set(chunk, position);\n        position += chunk.length;\n      }\n\n      blob = new Blob([allChunks.buffer], { type: contentType || undefined });\n    }\n\n    const result = await this.writeFile({\n      path: options.path,\n      directory: options.directory ?? undefined,\n      recursive: options.recursive ?? false,\n      data: blob,\n    });\n\n    return { path: result.uri, blob };\n  };\n\n  private isBase64String(str: string): boolean {\n    try {\n      return btoa(atob(str)) == str;\n    } catch (err) {\n      return false;\n    }\n  }\n}\n\ninterface EntryObj {\n  path: string;\n  folder: string;\n  type: 'directory' | 'file';\n  size: number;\n  ctime: number;\n  mtime: number;\n  uri?: string;\n  content?: string | Blob;\n}\n"],"names":["resolve","path","posix","split","filter","item","newPosix","forEach","length","pop","push","join","isPathParent","parent","children","pathsA","pathsB","every","value","index","FilesystemWeb","_WebPlugin","_inherits","_super","_createSuper","_this","_classCallCheck","DB_VERSION","DB_NAME","_writeCmds","downloadFile","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","_a","_b","requestInit","response","blob","reader","bytes","chunks","contentType","contentLength","_yield$reader$read","done","status","allChunks","position","_i","_chunks","chunk","result","wrap","_context","prev","next","buildRequestInit","webFetchExtra","fetch","url","sent","progress","body","Blob","getReader","headers","get","parseInt","read","abrupt","notifyListeners","Uint8Array","set","buffer","type","undefined","writeFile","directory","recursive","data","uri","stop","_x","apply","arguments","_createClass","key","_initDb","_callee2","_this2","_context2","this","_db","window","unavailable","Promise","reject","request","indexedDB","open","onupgradeneeded","doUpgrade","onsuccess","onerror","error","onblocked","console","warn","_dbRequest","_callee3","cmd","args","readFlag","_context3","indexOf","initDb","then","conn","store","transaction","objectStore","req","_toConsumableArray","_x2","_x3","_dbIndexRequest","_callee4","indexName","_context4","_x4","_x5","_x6","uriPath","cleanedUriPath","replace","fsPath","_clear","_callee5","tx","_context5","clear","_readFile","_callee6","entry","_context6","getPath","dbRequest","Error","content","_x7","_writeFile","_callee7","encoding","doRecursive","occupiedEntry","parentPath","subDirIndex","parentArgPath","now","pathObj","_context7","substr","lastIndexOf","mkdir","isBase64String","Date","folder","size","ctime","mtime","_x8","_appendFile","_callee8","_context8","btoa","atob","_x9","_deleteFile","_callee9","_context9","dbIndexRequest","IDBKeyRange","only","_x10","_mkdir","_callee10","depth","parentEntry","_context10","match","_x11","_rmdir","_callee11","fullPath","readDirResult","_iterator","_step","_entry","entryPath","_context11","readdir","files","_createForOfIteratorHelper","s","n","concat","name","stat","deleteFile","rmdir","t0","e","f","finish","_x12","_readdir","_callee13","entries","_this3","_context13","all","map","_ref2","_callee12","subEntry","_context12","substring","_x14","_x13","_getUri","_callee14","_context14","_x15","_stat","_callee15","_context15","_x16","_rename","_callee16","_context16","_copy","_x17","_copy2","_callee17","_context17","_x18","_requestPermissions","_callee18","_context18","publicStorage","_checkPermissions","_callee19","_context19","_copy3","_callee21","doRename","toDirectory","to","from","fromDirectory","fromPath","toPath","toObj","toPathComponents","_toPath","fromObj","updateTime","file","writeResult","contents","_iterator2","_step2","filename","_this4","_args21","_context21","_ref3","_callee20","_context20","_x20","_x21","_x22","t1","readFile","Encoding","UTF8","t2","t3","_x19","str","err","event","db","target","oldVersion","objectStoreNames","contains","deleteObjectStore","createObjectStore","keyPath","createIndex","WebPlugin","_debug"],"sourceRoot":""}